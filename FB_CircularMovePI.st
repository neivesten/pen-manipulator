//
// Circular move using a PI controller. The block keeps track of the current
// angle along the arc and computes a target point on the circle for every
// cycle. The velocity to this target is generated by two PI controllers.
//
FUNCTION_BLOCK FB_CircularMovePI
VAR_INPUT
    CurPos : POS2D;   // Current TCP position
    P1 : POS2D;       // Start point of the arc
    P2 : POS2D;       // Mid point defining the arc
    P3 : POS2D;       // End point of the arc
    MaxSpeed : REAL;  // Desired tangential speed [mm/s]
    Kp : REAL;        // Proportional gain
    Ki : REAL;        // Integral gain
    Ts : REAL;        // Cycle time [s]
END_VAR
VAR_IN_OUT
    SpeedX : REAL;    // Current speed command X (state on call)
    SpeedY : REAL;    // Current speed command Y (state on call)
END_VAR
VAR
    IntX : REAL;
    IntY : REAL;
    CenterX, CenterY : REAL;
    Radius : REAL;
    StartAngle : REAL;
    EndAngle : REAL;
    Angle : REAL;
    Dir : REAL;           // +1 CCW, -1 CW
    InitDone : BOOL := FALSE;
    ErrX, ErrY : REAL;
    TargetX, TargetY : REAL;
    SpeedMag : REAL;

    // Temporary variables for circle calculation
    dx12, dy12, dx23, dy23 : REAL;
    M12X, M12Y, M23X, M23Y : REAL;
    RHS1, RHS2, D : REAL;
    angleP2 : REAL;
END_VAR

IF NOT InitDone THEN
    dx12 := P2.X - P1.X;
    dy12 := P2.Y - P1.Y;
    dx23 := P3.X - P2.X;
    dy23 := P3.Y - P2.Y;

    M12X := (P1.X + P2.X) * 0.5;
    M12Y := (P1.Y + P2.Y) * 0.5;
    M23X := (P2.X + P3.X) * 0.5;
    M23Y := (P2.Y + P3.Y) * 0.5;

    D := dx12 * dy23 - dy12 * dx23;
    IF ABS(D) < 0.0001 THEN
        CenterX := 0.0;
        CenterY := 0.0;
        Radius := 1.0;
    ELSE
        RHS1 := dx12 * M12X + dy12 * M12Y;
        RHS2 := dx23 * M23X + dy23 * M23Y;
        CenterX := (RHS1 * dy23 - dy12 * RHS2) / D;
        CenterY := (dx12 * RHS2 - RHS1 * dx23) / D;
        Radius := SQRT((P1.X - CenterX)*(P1.X - CenterX) + (P1.Y - CenterY)*(P1.Y - CenterY));
    END_IF;

    StartAngle := FU_atan2(P1.Y - CenterY, P1.X - CenterX);
    EndAngle := FU_atan2(P3.Y - CenterY, P3.X - CenterX);
    angleP2 := FU_atan2(P2.Y - CenterY, P2.X - CenterX);

    IF ((StartAngle < EndAngle) AND (angleP2 > StartAngle) AND (angleP2 < EndAngle)) OR
       ((StartAngle > EndAngle) AND NOT (angleP2 > EndAngle AND angleP2 < StartAngle)) THEN
        Dir := 1.0; // CCW
    ELSE
        Dir := -1.0; // CW
    END_IF;

    Angle := StartAngle;
    InitDone := TRUE;
END_IF;

TargetX := CenterX + Radius * COS(Angle);
TargetY := CenterY + Radius * SIN(Angle);

ErrX := TargetX - CurPos.X;
ErrY := TargetY - CurPos.Y;

IntX := IntX + Ki * ErrX * Ts;
IntY := IntY + Ki * ErrY * Ts;

IF IntX > MaxSpeed THEN
    IntX := MaxSpeed;
ELSIF IntX < -MaxSpeed THEN
    IntX := -MaxSpeed;
END_IF;
IF IntY > MaxSpeed THEN
    IntY := MaxSpeed;
ELSIF IntY < -MaxSpeed THEN
    IntY := -MaxSpeed;
END_IF;

SpeedX := Kp * ErrX + IntX;
SpeedY := Kp * ErrY + IntY;

IF SpeedX > MaxSpeed THEN
    SpeedX := MaxSpeed;
ELSIF SpeedX < -MaxSpeed THEN
    SpeedX := -MaxSpeed;
END_IF;
IF SpeedY > MaxSpeed THEN
    SpeedY := MaxSpeed;
ELSIF SpeedY < -MaxSpeed THEN
    SpeedY := -MaxSpeed;
END_IF;

SpeedMag := SQRT(SpeedX * SpeedX + SpeedY * SpeedY);
IF Radius > 0 THEN
    Angle := Angle + Dir * (SpeedMag / Radius) * Ts;
END_IF;

// End of FB_CircularMovePI
